Index: sketch.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//p5.js sketch file (with p5 in instance mode we can rename this file)\r\n//https://p5js.org/reference/\r\n//https://p5js.org/reference/#/libraries/p5.sound\r\n\r\n/*\r\nTODO:\r\nadd a background image to make everything prettier\r\nmaybe add some stupid effects to make things even more pretty\r\n\r\nRECORDING MODE:\r\n-Implement recording\r\n\r\nUPLOAD MODE:\r\n-Bring debug fixes (disappearing waveform,etc)\r\n\r\n(note: both modes bring to common mode)\r\n\r\nCOMMON MODE:\r\n-Peak detection\r\n-Polyrhythm detection\r\n-Cut audio if longer than 30 seconds\r\n\r\nIF THERE'S TIME:\r\n-Implement a createGraphics approach to manage helper text\r\n*/\r\n\r\n/*\r\nTone stuff\r\n*/\r\n/*\r\nTone.Transport.bpm.value = 80;\r\n// start/stop the oscillator every quarter note\r\nTone.Transport.scheduleRepeat(time => {\r\n  osc.start(time).stop(time + 0.1);\r\n}, \"4n\");\r\nTone.Transport.start();\r\n// ramp the bpm to 120 over 10 seconds\r\nTone.Transport.bpm.rampTo(120, 10);\r\n*/\r\n\r\n//needed until we find a better way to track document focus changes\r\n//(see bottom of this file)\r\n//this just tracks the state\r\nvar pageFoc = true;\r\n\r\n//we set the bpm to 100 by default; this will be the bpm\r\n//the user will be asked to play/upload something at\r\nvar bpm = 100\r\n\r\n//recording: booelan indicating if we're recording or not\r\nvar recordedAudio; //for the soundRecorder\r\nvar recording = false;\r\n\r\n//MENU BUTTONS\r\n//used to create an upload button spanning half a page\r\nvar visibleUploadButton;\r\n//the real upload button, hidden in the back :)\r\nvar realUploadButton;\r\nvar uploadButton;\r\n\r\n//same idea as above, a bit simpler \r\nvar recordSideButton;\r\n\r\n//various other self-explanatory buttons\r\nvar faqMenuButton; //onclick:show instructions\r\n\r\n//buttons to control the audio playback\r\nvar playButton;\r\nvar stopButton;\r\nvar stopButton;\r\nvar recordButton;\r\n\r\n\r\nvar soundFile; //the file we'll load\r\nvar leftChannel, rightChannel; //we'll save the audio values in here\r\n\r\nvar messages; //to save the messages we'll display\r\n\r\n//use p5 in instance mode\r\np5_instance = function (p5c) {\r\n  class Message {\r\n    /*\r\n    Message: class that represents a message that the helper will say\r\n    Important fields of a Message:\r\n    msg: the actual message\r\n    id: the id of the message\r\n    nextMsgId: the id of the next message the helper will say\r\n    */\r\n    constructor(msg, id, nextMsgId) {\r\n      if (msg != null && msg != undefined) {\r\n        this.msg = msg\r\n      } else {\r\n        this.msg = \"\"\r\n      }\r\n      if (id != null && id != undefined) {\r\n        this.id = id\r\n      } else {\r\n        this.id = \"\"\r\n      }\r\n      if (nextMsgId != null && nextMsgId != undefined) {\r\n        this.nextMsgId = nextMsgId\r\n      } else {\r\n        this.nextMsgId = -1\r\n      }\r\n      //this.prevMsgId = -1\r\n    }\r\n    //used for emptying the dialogue box without switching to another message\r\n    //Especially useful for when we don't want to display a new message immediately\r\n    makeEmpty() {\r\n      this.msg = \"\"\r\n    }\r\n    setId(id) {\r\n      this.id = id\r\n    }\r\n    getId() {\r\n      return this.id\r\n    }\r\n    getMsg() {\r\n      return this.msg\r\n    }\r\n    setMsg(msg) {\r\n      this.msg = msg\r\n    }\r\n    setNextMsgId(nextMsgId) {\r\n      this.nextMsgId = nextMsgId\r\n    }\r\n    //this is useless, could be used to check for errors\r\n    setPrevMsgId(prevMsgId) {\r\n      this.prevMsgId = prevMsgId\r\n    }\r\n  }\r\n\r\n  //-----------------------end of Message-------------------------\r\n\r\n  class Helper {\r\n    /*\r\n    Helper: the helper is the character that is displayed on the screen\r\n    and says stuff to help the user\r\n    --Inputs--\r\n    faces: array of faces (images of a face) of the helper\r\n    name: the name of the helper\r\n    */\r\n    constructor(faces, name) {\r\n      this.name = name //displayed name (e.g. \"Polyev\")\r\n      //the parameters are the faces of the helper\r\n      this.faces = faces //this could be an array of images or a single image\r\n      //for now we'll not distinguish by emotion (=> we use a single face)\r\n      this.currFace = 0\r\n\r\n      //count the frames you showed the last face for\r\n      //this.showedFor = 0\r\n\r\n      this.lastMsg = \" \"\r\n      this.counter = 0  //counts how many characters of the message have been displayed\r\n      this.time = 20 //time between each character\r\n\r\n      //we have reached the end of the phrase\r\n      this.wait = false  //true if we're waiting for the user to press a key\r\n      this.interval = null //the interval that will be used to play a \"speech\" sound\r\n      this.cursorBlink = false //used to manage the blinking cursor\r\n      this.isIdle = false //is the helper idle? (not saying anything - no new messages)\r\n      this.state = \"working\" //the state of the helper (working, idle, etc)\r\n    }\r\n\r\n    /*\r\n    showFace: displays the face of the helper\r\n    */\r\n    showFace() {\r\n      if (!started)\r\n        p5c.image(this.faces[this.currFace], p5c.width - 400, p5c.height - 400)\r\n      else {\r\n        p5c.image(this.faces[this.currFace], p5c.width / 14, 2 * p5c.height / 4)\r\n      }\r\n      /*\r\n      //this made more sense when there were multiple faces\r\n      this.showedFor++\r\n      if(this.showedFor == 5){\r\n        this.currFace++\r\n        this.currFace = this.currFace%this.faces.length\r\n        this.showedFor = 0\r\n      }\r\n      */\r\n    }\r\n\r\n    /*\r\n    createTextBox: creates the text box where the helper will say stuff\r\n    Also manages the blinking cursor on the bottom right of the text box\r\n    */\r\n    createTextBox() {\r\n      //create a text box\r\n      //the text is in the middle of the rect\r\n      p5c.rectMode(p5c.CENTER)\r\n      p5c.fill(12, 12, 12, 150)\r\n      p5c.rect(p5c.width / 2, p5c.height - 150, p5c.width / 2, 200)\r\n      //print message using speech_font\r\n      p5c.stroke(255)\r\n      p5c.fill(255)\r\n      p5c.textFont(speech_font)\r\n      p5c.textSize(30)\r\n      p5c.rectMode(p5c.CORNER)\r\n      p5c.textWrap(p5c.WORD) //alternative is CHAR \r\n      //if the helper is waiting for the user to click, show a blinking cursor\r\n      if (this.wait && !this.isIdle) {\r\n        if (p5c.frameCount % 30 == 0) {\r\n          this.cursorBlink = !this.cursorBlink\r\n        }\r\n        if (!this.cursorBlink) {\r\n          //draw a small white square on the bottom right of the text box (the cursor)\r\n          p5c.rect(3 / 4 * p5c.width - 25, p5c.height - 75, 15, 15)\r\n        }\r\n      }\r\n    }\r\n    /*\r\n    addAuthor: adds the name of the helper on the top left corner of the text box\r\n    */\r\n    addAuthor() {\r\n      //The name is inside a rectangle with a white background\r\n      //TODO: this part is more of a meme, you decide if we keep it or not\r\n      p5c.push()\r\n      p5c.fill(255)\r\n      p5c.rect(p5c.width / 4, p5c.height - 300, p5c.width / 6, 50)\r\n      p5c.fill(0)\r\n      p5c.textSize(32)\r\n      p5c.textAlign(p5c.LEFT)\r\n      p5c.text(this.name, p5c.width / 4 + 10, p5c.height - 300 + 20)\r\n      p5c.pop()\r\n    }\r\n    /*\r\n    say: displays the message on the screen\r\n    --Inputs--\r\n    message: Message object containing the string to print\r\n    */\r\n    say(message) {\r\n      //need to get the message from the message object\r\n      let msg = message.getMsg()\r\n      let time = this.time\r\n      //print textbox and helper name\r\n      this.createTextBox()\r\n      this.addAuthor()\r\n\r\n      if (this.lastMsg != msg) {\r\n        //if the message is different from the last one in memory update it\r\n        this.lastMsg = msg\r\n        this.counter = 1\r\n        //setTimeout(this.printMsg, this.counter*time, this.lastMsg, this.counter);\r\n        this.printMsg(msg, this.counter)\r\n        this.wait = false\r\n        //upgrade counter by one and play the sound corresponding to dialogue\r\n        this.interval = setInterval(() => {\r\n          this.counter++\r\n          //play the sound corresponding to dialogue\r\n          //(every once in a while)\r\n          if (this.counter % 5 == 0) {\r\n            speech.play()\r\n          }\r\n          if (this.counter > msg.length) {\r\n            this.wait = true\r\n          }\r\n        }, time);\r\n      } else { //if the message is the same as the last one in memory\r\n        if (this.counter >= msg.length) {\r\n          //if we've reached the end of the message stop increasing the counter\r\n          //and making sounds\r\n          clearInterval(this.interval)\r\n          this.printMsg(msg, msg.length)\r\n          //wait for user input (=>show blinking cursor)\r\n          this.wait = true\r\n          return\r\n        }\r\n        //setTimeout(this.printMsg, this.counter * time, this.lastMsg, this.counter);\r\n\r\n        //TODO: this is kinda unnedeed here...\r\n        this.printMsg(msg, this.counter)\r\n      }\r\n    }\r\n    /*\r\n    //not needed anymore, it's all done inside of say()\r\n    updateCounter(time,msg, intervalHandle,cnt){\r\n      cnt++\r\n      if(cnt) > msg.length){\r\n        clearInterval(this.interval)\r\n        this.wait = false\r\n        return\r\n      }\r\n    }\r\n    */\r\n\r\n    /*\r\n     printMsg: actually prints the message on the screen\r\n     --Inputs--\r\n     msg: the message to print\r\n     to: the number of characters to print\r\n    */\r\n    printMsg(msg, to) {\r\n      p5c.stroke(255)\r\n      p5c.text(msg.substring(0, to),\r\n        1 * p5c.width / 4 + 10, p5c.height - 250, p5c.width / 2 - 20, 200)\r\n    }\r\n\r\n    //------------------------------------------------\r\n    //functions to manage the state of the helper\r\n\r\n    isWaiting() {\r\n      //is waiting for user input\r\n      return this.wait && !this.isIdle\r\n    }\r\n    setIdle() {\r\n      //is idle means that it's NOT expecting any user input\r\n      //and it's not displaying anything on the screen\r\n      this.isIdle = true\r\n      this.state = \"idle\"\r\n    }\r\n    setWorking() {\r\n      //opposite of setIdle()\r\n      this.isIdle = false\r\n      this.state = \"working\"\r\n    }\r\n    getState() {\r\n      return this.state\r\n    }\r\n    //------------------------------------------------\r\n  }\r\n  //-----------------------end of Helper-------------------------\r\n\r\n  //variables to handle the state of the application\r\n  let loading = true //is the application loading stuff?\r\n  var started = false; //has the user started the game?\r\n  var userGaveMicPerm = false; //has the user given microphone permission?\r\n\r\n  /*\r\n  preload: function that gets automatically by p5js before loading the sketch.\r\n  ->Everything that needs to be available when the sketch starts needs to be loaded here\r\n  (e.g. fonts, sounds,...)\r\n  */\r\n  p5c.preload = function () {\r\n    //soundFormats('wav');\r\n    //hit = p5c.loadSound('assets/hit.wav');\r\n    //miss = p5c.loadSound('assets/miss.wav')\r\n    //met1 = p5c.loadSound('assets/met1.wav'); //metronome (higher)\r\n    met2 = p5c.loadSound('assets/met2.wav'); //metronome (lower)\r\n    font = p5c.loadFont('assets/Gruppo-Regular.ttf'); //fancy font\r\n    speech_font = p5c.loadFont('assets/Montserrat-Light.ttf') //font for the text box\r\n    face = p5c.loadImage('assets/face.png') //helper's face\r\n    face_talking1 = p5c.loadImage('assets/face_talking1.png'); //helper's face while talking\r\n    face_talking2 = p5c.loadImage('assets/face_talking2.png'); //helper's face while talking\r\n    speech = p5c.loadSound('assets/dialogue.wav') //sound for the dialogue\r\n    speech_end = p5c.loadSound('assets/dialogue_end.wav') //sound that plays when user clicks to pass to next message\r\n    messages_json = p5c.loadJSON('assets/messages.json', jsonLoaded) //json file containing the Messages\r\n\r\n    debug_soundfile = p5c.loadSound('assets/song2_lq.mp3') //debug soundfile\r\n\r\n    bg = p5c.loadImage('assets/bg.jpg') //background image\r\n  }\r\n\r\n  /*\r\n  jsonLoaded: function that gets called when messages_json is loaded\r\n  Creates an array for the messages\r\n  */\r\n  jsonLoaded = function () {\r\n    let n = Object.keys(messages_json[\"record\"]).length\r\n    messages = new Array(n)\r\n    for (let i = 0; i < n; i++) {\r\n      let msg = messages_json[\"record\"][i]\r\n      messages[i] = new Message(msg.msg, msg.msgId, msg.nextMsgId)\r\n    }\r\n    loading = false\r\n  }\r\n\r\n  //we need these to record using p5.js\r\n  var mic, recorder; //mic = our microphone, recorder is a p5.soundRecorder\r\n  //var soundFile; //the file we'll load\r\n  //var leftChannel, rightChannel;\r\n  var fft; //needed to analyse the sound\r\n\r\n  var mode; //0 = record from mic, 1 = load from file, 2 = common (after the first set of dialogues everything is common)\r\n  /*\r\n  setup(): function that gets called by p5.js at startup. Initialise variables \r\n  needed in the sketch here; load audio files, fonts, etc, in preload() instead\r\n  */\r\n  p5c.setup = function () {\r\n    p5c.createCanvas(p5c.windowWidth, p5c.windowHeight);\r\n    /*\r\n    see https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/suspend\r\n    There's no need for the audio context to be running as soon as the page is loaded\r\n    */\r\n    p5c.getAudioContext().suspend();\r\n    p5c.frameRate(60) //this doesn't work but it's like lighting a candle \r\n    //in a church praying for a miracle\r\n\r\n    setupAudioStuff()\r\n\r\n    faces = [face]//, face2]\r\n    helper = new Helper(faces, \"Polyev\")\r\n    msg = messages[0]\r\n\r\n    //setup everything regarding buttons\r\n    setupMenuButtons()\r\n  }\r\n  /* \r\n  setupAudioStuff: sets up, you guessed it, the audio stuff related to p5js\r\n  */\r\n  setupAudioStuff = function () {\r\n    //we need to initialise the microphone and the recorder\r\n    mic = new p5.AudioIn();\r\n    recorder = new p5.SoundRecorder();\r\n    //we set the input of the recorder to be the microphone\r\n    recorder.setInput(mic);\r\n    //here we would start the microphone, but we don't want to do that yet\r\n    //We'll start only when if the user selects to record\r\n    //This is handled in the handleMessage() function\r\n    //we create a soundFile that will contain a pre-recorded audio\r\n    soundFile = new p5.SoundFile();\r\n    fft = new p5.FFT();\r\n    //we set the input of the fft to be the microphone\r\n\r\n    //fft.setInput(mic);\r\n    //TODO after recording we need to call mic.disconnect()\r\n\r\n    fft.setInput();\r\n  }\r\n\r\n  /*\r\n  setupMenuButtons: setup the buttons that are used in the menu\r\n  Contains a mousePressed function for every button to handle what \r\n  to do when the user clicks on it\r\n  */\r\n  setupMenuButtons = function () {\r\n    //we have the real upload button hidden behind a the visible one\r\n    realUploadButton = p5c.createFileInput(handleFile)\r\n    //hide realUploadButton and give it the realUpload ID\r\n    realUploadButton.hide()\r\n    realUploadButton.id('realUpload')\r\n    uploadButton = document.getElementById('realUpload')\r\n    visibleUploadButton = p5c.createButton('');\r\n    visibleUploadButton.addClass('upload_button')\r\n    visibleUploadButton.id('menuUploadButton')\r\n    //make visibleUploadButton hidden and a file input\r\n    visibleUploadButton.attribute('type', 'file')\r\n    visibleUploadButton.attribute('accept', 'audio/*')\r\n\r\n    recordSideButton = p5c.createDiv('')\r\n    recordSideButton.addClass('record_side')\r\n\r\n    faqMenuButton = p5c.createDiv('?')\r\n    faqMenuButton.addClass('faq_button')\r\n\r\n    //two cases:\r\n    //if the user clicked on the left half of the window:\r\n    //ask for the BPM the user wants, ask for permission to use the microphone\r\n    //and start recording\r\n    //if the user clicked on the right half of the window:\r\n    //open a file selector and ask the user to select a file\r\n    recordSideButton.mousePressed(function () {\r\n      bpm = p5c.createInput(\"What BPM do you want to use?\");\r\n      mode = 0 //user chose to record\r\n      //started = true\r\n      if (!started) {\r\n        p5c.userStartAudio();\r\n        Tone.start();\r\n        //Tone.Transport.start();\r\n        //startMetronome(bpm)\r\n        //Tone.Transport.bpm.value = bpm;\r\n        started = true\r\n      }\r\n      removeUselessButtons()\r\n    })\r\n\r\n\r\n\r\n    faqMenuButton.mousePressed(function () {\r\n      //TODO: type all FAQs, everything the user needs to know, inside a black box\r\n      //Make it look nice and make it close when user clicks on it\r\n      faqMenuButton.hide()\r\n      //make a black box in the middle of the screen and type \"aaa\" inside of it\r\n      let box = p5c.createDiv(`<h2>HOW THIS WORKS</h2>\r\n      Welcome to the didactic mode of Polyrhythm Hero!<br>\r\n      In this mode, you will learn how to play basic polyrhythms.<br>\r\n      You can choose to record yourself playing some kind of rhythm (tapping your fingers on the table is also OK) \r\n      or upload an audio file from your pc.<br>\r\n      For simplicity, all recordings will be cut to 30 seconds<br>\r\n      The website will then analyze your audio and find the polyrhythm that's closest to what you played.<br>\r\n      You can then choose to train on the polyrhythm you found, play with it on a rhythmic wheel to obtain shifted versions \r\n      or record/upload a new audio.<br>\r\n      <br>\r\n      COMMANDS:<br>\r\n      z: pass to the helper's next message<br>\r\n      m: skip all useless dialogue and get into the action right away<br>\r\n      <br>\r\n      We hope you enjoy your stay!<br>\r\n      <br>\r\n      <b>Alice, Cecilia, Francesco, Matteo</b>`)\r\n      box.addClass('faq_box')\r\n      //box.position(p5c.width/2, p5c.height/2 - 100)\r\n      box.size(600, 600)\r\n      box.mousePressed(function () {\r\n        box.remove()\r\n        faqMenuButton.show()\r\n      }\r\n      )\r\n    })\r\n\r\n    visibleUploadButton.mousePressed(function () {\r\n      //p5c.userStartAudio()\r\n      mode = 1\r\n      //started = true\r\n      if (!started) {\r\n        p5c.userStartAudio();\r\n        Tone.start();\r\n        //Tone.Transport.start();\r\n        //startMetronome(bpm)\r\n        //Tone.Transport.bpm.value = bpm;\r\n        //started = true\r\n      }\r\n      //click the \"real\" button, thus prompting file load\r\n      uploadButton.click()\r\n      /*\r\n      //now remove all useless buttons\r\n      realUploadButton.remove()\r\n      //visibleUploadButton.hide()\r\n      visibleUploadButton.remove()\r\n      */\r\n    })\r\n  }\r\n  //var frameCounter = 0; //not used now, might be used to count frames IN GAME\r\n\r\n  /*\r\n  draw(): p5js function that gets automatically called once per frame\r\n  (by default 60 frames per second) \r\n  */\r\n  p5c.draw = function () {\r\n    p5c.background(12);\r\n    if (loading)\r\n      //we're still loading the messages (JSON loading is async)\r\n      return\r\n\r\n    if (started) {\r\n      drawCurrentMode()\r\n    }\r\n    else {\r\n      drawMenu()\r\n    }\r\n  }\r\n\r\n  /*\r\n  drawCurrentMode: draw but for the current mode (record, upload, common)\r\n  */\r\n  drawCurrentMode = function () {\r\n    //show bg image in the background\r\n    p5c.image(bg, 0, 0, p5c.width, p5c.height)\r\n    switch (mode) {\r\n      case 0:\r\n        //we're in record mode\r\n        helper.showFace()\r\n        helper.say(msg)\r\n        break;\r\n      case 1:\r\n        //we're in upload mode\r\n        helper.showFace()\r\n        helper.say(msg)\r\n        break;\r\n      case 2:\r\n        //COMMON MODE\r\n        drawInterface()\r\n        helper.showFace()\r\n        helper.say(msg)\r\n        break;\r\n    }\r\n  }\r\n\r\n  /*\r\n  drawInterface: draw the interface of the common mode (buttons, waveform display, etc)\r\n  */\r\n  drawInterface = function () {\r\n    //draw audio controls\r\n    drawAudioControls()\r\n\r\n    //draw a basic rectangle that will contain the waveform of the recorded/uploaded audio\r\n    p5c.push()\r\n    p5c.stroke(255)\r\n    p5c.strokeWeight(2)\r\n    p5c.fill(12, 12, 12, 150)\r\n    p5c.rectMode(p5c.CENTER)\r\n    p5c.rect(p5c.width / 2, p5c.height / 4, 3 * p5c.width / 4, p5c.height / 3)\r\n\r\n    if (leftChannel != null) {\r\n      //draw the waveform\r\n      p5c.stroke(255)\r\n      p5c.strokeWeight(2)\r\n      p5c.noFill()\r\n      let resolution = p5c.int(p5c.max(1, p5c.round(leftChannel.length / (3 * p5c.width / 4))));\r\n      let x = p5c.width / 2 - 3 * p5c.width / 8;\r\n      let sum = 0;\r\n      let maxAmp; //maximum amplitude\r\n      for (let i = 0; i < leftChannel.length; i++) {\r\n        if (maxAmp === undefined || p5c.abs(leftChannel[i]) > maxAmp) {\r\n          maxAmp = leftChannel[i];\r\n        }\r\n      }\r\n      maxAmp = maxAmp / 2;\r\n\r\n      p5c.beginShape()\r\n      for (let i = 0; i < leftChannel.length; i++) {\r\n        // Compute an average for each set of values\r\n        sum += p5c.abs(leftChannel[i]);\r\n        if (i % resolution == 0) {\r\n          p5c.vertex(\r\n            x++,\r\n            // map the average amplitude to range from the center of the canvas to\r\n            // either the top or bottom depending on the channel\r\n            p5c.map(sum / resolution, 0, maxAmp, p5c.height / 4 + p5c.height / 6, p5c.height / 4 - p5c.height / 6)\r\n          );\r\n          sum = 0;\r\n        }\r\n      }\r\n      p5c.endShape()\r\n    }\r\n\r\n    p5c.pop()\r\n\r\n\r\n    p5c.push()\r\n    //draw a light blue line that will represent the current position in soundFile playback\r\n    p5c.stroke(0, 255, 255)\r\n    p5c.strokeWeight(2)\r\n    p5c.noFill()\r\n    //player current X position\r\n    let playerCurrX = p5c.map(soundFile.currentTime(), 0, soundFile.duration(), p5c.width / 2 - 3 * p5c.width / 8, p5c.width / 2 + 3 * p5c.width / 8)\r\n    p5c.line(playerCurrX, p5c.height / 4 - p5c.height / 6 + 1, playerCurrX, p5c.height / 4 + p5c.height / 6 - 1) //+1,-1 to avoid overlapping with the window\r\n\r\n    p5c.pop()\r\n\r\n\r\n    /*\r\n    //This is very nice to see but quite useless since we're reading only a small sample in real time\r\n    //draw the waveform\r\n    let waveform = fft.waveform()\r\n    p5c.stroke(255)\r\n    p5c.strokeWeight(2)\r\n    p5c.noFill()\r\n    p5c.beginShape()\r\n    for (var i = 0; i < waveform.length; i++){\r\n      var x = p5c.map(i, 0, waveform.length, p5c.width/4, p5c.width/4 + p5c.width/2);\r\n      var y = p5c.map( waveform[i], -1, 1, p5c.height/3 + p5c.height/3, p5c.height/3);\r\n      p5c.vertex(x,y);\r\n    }\r\n    p5c.endShape()\r\n    p5c.pop()\r\n    */\r\n  }\r\n\r\n  /*\r\n  drawAudioControls: draw the audio controls (play, pause, stop, etc)\r\n  TODO: chose a different implementation for now (once created they stay\r\n  see createAudioControls())\r\n  */\r\n  drawAudioControls = function () {\r\n    p5c.push()\r\n\r\n    p5c.pop()\r\n  }\r\n\r\n  /*\r\n  drawMenu: draw the menu (the first screen)\r\n  */\r\n  drawMenu = function () {\r\n    //we're in the menu\r\n    p5c.textFont(font);\r\n    //divide the screen in half;\r\n\r\n    //fill the left side with a gradient from blu to purple\r\n    //using lerpColor() by subdividing it into 50 parts\r\n    p5c.noStroke()\r\n    for (var i = 0; i < 100; i++) {\r\n      p5c.fill(p5c.lerpColor(p5c.color(0, 0, 255), p5c.color(255, 0, 255), i / 100));\r\n      p5c.rect(0, p5c.height / 100 * i, p5c.width / 2, p5c.height / 100);\r\n    }\r\n    //fill the right side with a gradient from red to purple\r\n    //using lerpColor() by subdividing it into 50 parts\r\n    for (var i = 0; i < 100; i++) {\r\n      p5c.fill(p5c.lerpColor(p5c.color(255, 0, 0), p5c.color(255, 0, 255), i / 100));\r\n      p5c.rect(p5c.width / 2, p5c.height / 100 * i, p5c.width / 2, p5c.height / 100);\r\n    }\r\n\r\n    p5c.stroke(255)\r\n    p5c.line(p5c.width / 2, 0, p5c.width / 2, p5c.height)\r\n    helper.showFace()\r\n    //left side \"Record\" side\r\n    //right side: \"Upload\" side\r\n    p5c.textSize(50);\r\n    p5c.textAlign(p5c.CENTER, p5c.CENTER);\r\n    p5c.fill(255);\r\n    p5c.text(\"Record some sounds\", p5c.width / 4, p5c.height / 2);\r\n    p5c.text(\"Upload a file\", p5c.width * 3 / 4, p5c.height / 2);\r\n    p5c.textSize(30);\r\n    p5c.text(\"(OR)\", p5c.width / 2, p5c.height / 2 - 50);\r\n    //create an arrow pointing to (width-400,height-200) with the text\r\n    //\"your helper\" below it\r\n    p5c.textSize(20);\r\n    p5c.text(\"your helper\", p5c.width - 450, p5c.height - 200 + 50);\r\n    p5c.stroke(255)\r\n    p5c.noFill()\r\n    p5c.bezier(\r\n      p5c.width - 550, p5c.height - 70,\r\n      p5c.width - 550, p5c.height - 200,\r\n      p5c.width - 450, p5c.height - 250,\r\n      p5c.width - 400, p5c.height - 250\r\n    )\r\n    //we will show the face of the helper here using other functions\r\n    p5c.line(p5c.width - 400, p5c.height - 250, p5c.width - 425, p5c.height - 200)\r\n    p5c.line(p5c.width - 400, p5c.height - 250, p5c.width - 425, p5c.height - 275)\r\n\r\n    //write \"POLYRHYTHM HERO\" in the upper middle part of the screen.\r\n    //Write it using p5.js functions in a geometric pattern, making it stick out\r\n    //from the background\r\n\r\n    p5c.textSize(150);\r\n    p5c.textAlign(p5c.CENTER, p5c.CENTER);\r\n    p5c.fill(255);\r\n    p5c.text(\"POLYRHYTHM HERO\", p5c.width / 2, p5c.height / 6);\r\n\r\n    //write the authors right below the title\r\n    p5c.textSize(32);\r\n    p5c.textAlign(p5c.CENTER, p5c.CENTER);\r\n    p5c.fill(255);\r\n    p5c.text(\"by Francesco Colotti, Matteo Gionfriddo, Cecilia Raho and Alice Sironi\", p5c.width / 2, p5c.height / 6 + 100);\r\n  }\r\n\r\n  /* \r\n  windowResized(): p5js function that gets called every time the window\r\n  gets resized; recalculate here all the variables that contain coordinates \r\n  in their formulas\r\n  */\r\n  p5c.windowResized = function () {\r\n    //p5c.removeElements();\r\n    p5c.resizeCanvas(p5c.windowWidth, p5c.windowHeight);\r\n  }\r\n  /* \r\n  mousePressed(): p5js function that gets called every time a mouse button\r\n  is pressed / the touchscreen is touched.\r\n  We start the AudioContext here with userStartAudio()\r\n  */\r\n  p5c.mousePressed = function () {\r\n\r\n  }\r\n\r\n  /*\r\n  handleFile: handles the file that the user has uploaded\r\n  Needed to actually load the file, extract data from it and update mode \r\n  */\r\n  handleFile = function (file) {\r\n    let sf = new p5.File(file)\r\n    //TODO: implement proper audio file loading\r\n    soundFile = p5c.loadSound(file, () => {\r\n      //if you need to test the file is loaded, uncomment this line\r\n      //soundFile.play()\r\n      //setTimeout(() => {\r\n      leftChannel = soundFile.buffer.getChannelData(0).slice()\r\n      //}, 3000);\r\n    })\r\n    //now remove all useless buttons\r\n    removeUselessButtons()\r\n    setTimeout(() => {\r\n      mode = 1 //user chose their file\r\n      //show some intro messages and then move to mode 2\r\n      console.log(\"FILE MODE\")\r\n      loadMessages(\"upload\")\r\n      started = true;\r\n    }, 1000);\r\n  }\r\n\r\n  /*\r\n  loadMessages: loads the messages from the json file\r\n  --Inputs--\r\n  messages_key: the key (in the json) of the message array to load (see json file)\r\n                each message array is a list of messages that the user will see\r\n                in a particular mode/moment\r\n  */\r\n\r\n  loadMessages = function (messages_key) {\r\n    let n = Object.keys(messages_json[messages_key]).length\r\n    messages = new Array(n)\r\n    for (let i = 0; i < n; i++) {\r\n      let msg = messages_json[messages_key][i]\r\n      messages[i] = new Message(msg.msg, msg.msgId, msg.nextMsgId)\r\n    }\r\n    msg = messages[0]\r\n    //reset message counter\r\n    currMessage = 0;\r\n    loading = false\r\n  }\r\n\r\n  /*\r\n  removeUselessButtons: removes the buttons after the user made their choice in the menu\r\n  TODO: could be used for more buttons\r\n  */\r\n  removeUselessButtons = function () {\r\n    realUploadButton.remove()\r\n    //visibleUploadButton.hide()\r\n    visibleUploadButton.remove()\r\n    faqMenuButton.remove()\r\n    recordSideButton.remove()\r\n  }\r\n\r\n  /* \r\n  keyPressed(): p5js function that gets called every time a key is pressed.\r\n  Use key to get the specific key.\r\n  */\r\n  var currMessage = 0\r\n  p5c.keyPressed = function () {\r\n    let key = p5c.key;\r\n    let keyCode = p5c.keyCode; //needed for special keys\r\n\r\n    //if the user presses 'z' or 'Z' and the game is not paused\r\n    //then he wants to skip to the next message\r\n    if (key == 'z' || key == 'Z') {\r\n      //if (!paused) {\r\n      //if the game is not paused, \r\n      //check if the helper is waiting (isWaiting == true); if so,\r\n      //play the 'speech_end' sound and set isWaiting to false\r\n      if (helper.isWaiting()) {\r\n        speech_end.play();\r\n        handleMessage(msg.getId())\r\n        //switch msg to the next message to display\r\n        currMessage++\r\n        msg.makeEmpty()\r\n        if (msg.nextMsgId != -1) {\r\n          setTimeout(() => { msg = messages[currMessage] }, 150)\r\n        } else {\r\n          helper.setIdle()\r\n        }\r\n      }\r\n      //}\r\n\r\n      //TODO: handle this in a better way.\r\n      //There is no way for now to insert a non skippable pause between messages\r\n    }\r\n\r\n    //DEBUG: skip directly to mode 2\r\n    if (key == 'm' || key == 'M') {\r\n      //skip directly to mode 2\r\n      removeUselessButtons()\r\n\r\n      if (!started) {\r\n        //mode = 2;\r\n        p5c.userStartAudio();\r\n        Tone.start();\r\n        loadMessages(\"common\")\r\n        //started = true;\r\n        soundFile = debug_soundfile\r\n        //TODO: find a better implementation of this; unfortunately we can't do better for now\r\n        //Making this actually load is a pain in the ass, so I'll take this for now.\r\n        //If we try to load the right channel for some unexplained reason this breaks and doesn't load anything\r\n        //I think it's because the data isn't available yet when we look for it\r\n        setTimeout(() => {\r\n          //careful that if you play a soundFile you empty its buffer => leftChannel becomes an empty array\r\n          //We add slice() to effectively clone the array\r\n          leftChannel = soundFile.buffer.getChannelData(0).slice()\r\n        }, 100);\r\n        setTimeout(() => {\r\n          mode = 2;\r\n          requestMicrophoneAccess();\r\n\r\n          createAudioControls();\r\n          started = true\r\n        }, 200);\r\n      }\r\n    }\r\n\r\n    //spacebar: let user control the audio playback in a more convenient way\r\n    if (keyCode == 32) {\r\n      if (mode == 2)\r\n        if (!soundFile.isPlaying()) {\r\n          soundFile.play()\r\n        } else {\r\n          soundFile.pause()\r\n        }\r\n    }\r\n  }\r\n\r\n  var micCheck; //needed to check if the user gave us permission to access the microphone\r\n  /*\r\n  handleMessage: for special messages, we need to handle them differently. This is the function we use\r\n  */\r\n  handleMessage = function (id) {\r\n    switch (id) {\r\n      //recordIntro3: last message before asking the user for permission to access the microphone\r\n      case \"recordIntro3\":\r\n        requestMicrophoneAccess();\r\n        break;\r\n      case \"record2\":\r\n        //can begin common mode\r\n        mode = 2;\r\n        leftChannel = null;\r\n        createAudioControls();\r\n        loadMessages(\"common\")\r\n        break;\r\n      case \"upload3\":\r\n        //can begin common mode\r\n        mode = 2;\r\n        createAudioControls();\r\n        loadMessages(\"common\")\r\n        break;\r\n    }\r\n  }\r\n\r\n  requestMicrophoneAccess = function () {\r\n    //ask user permission to access the microphone\r\n    mic.start(obtainedMicPerm, errorMicPerm)\r\n    //check periodically if the user gave us permission to access the microphone\r\n    micCheck = setInterval(() => {\r\n      mic.start(obtainedMicPerm)\r\n    }, 1000)\r\n  }\r\n\r\n  /*\r\n  createAudioControls: used to create the audio controls when passing to common mode\r\n  TODO: add an upload button\r\n  TODO: add a volume slider\r\n  */\r\n  var waveRefreshInterval;\r\n\r\n  createAudioControls = function () {\r\n    recordButton = p5c.createDiv('')\r\n    recordButton.addClass('record_button')\r\n    recordButton.mousePressed(function () {\r\n      if(!recording){\r\n        soundFile = new p5.SoundFile();\r\n        //soundFile.buffer = 0;\r\n        recorder.record(soundFile);\r\n        recording = true;\r\n        recordingWaveDrawer(waveRefreshInterval, recording);\r\n      }else{\r\n        recorder.stop();\r\n        recording = false;\r\n        recordingWaveDrawer(waveRefreshInterval, recording);\r\n      }\r\n    })\r\n    playButton = p5c.createDiv('')\r\n    playButton.addClass('play_button')\r\n    playButton.mousePressed(function () {\r\n      if(recording){\r\n        recorder.stop();\r\n        recording = false;\r\n        recordingWaveDrawer(waveRefreshInterval, recording);\r\n      }\r\n      if(!soundFile!=null){\r\n        if (!soundFile.isPlaying()) {\r\n          soundFile.play()\r\n        } else {\r\n          soundFile.pause()\r\n        }\r\n      }\r\n    })\r\n    stopButton = p5c.createDiv(\"\")\r\n    stopButton.addClass('stop_button')\r\n    stopButton.mousePressed(function () {\r\n      if (recording) {\r\n        recorder.stop();\r\n        recording = false;\r\n        recordingWaveDrawer(waveRefreshInterval, recording);\r\n      }\r\n      if(soundFile!=null){\r\n        soundFile.stop()\r\n      }\r\n    })\r\n  }\r\n\r\n  recordingWaveDrawer = function (waveRefreshInterval, recording){\r\n    //for some reason the whole thing doesn't work at the end unless we do this bad shit\r\n    if(recording){\r\n      waveRefreshInterval = setInterval(() => {\r\n        leftChannel = soundFile.buffer.getChannelData(0).slice();\r\n      }, 300)\r\n      \r\n    }else{\r\n      clearInterval(waveRefreshInterval);\r\n      leftChannel = soundFile.buffer.getChannelData(0).slice();\r\n    }\r\n  };\r\n\r\n  //--------------------MICROPHONE PERMISSIONS--------------------\r\n\r\n  /*\r\n  errorMicPerm: if the user doesn't give us permission to access the microphone, we need to tell them how to fix it\r\n  */\r\n  errorMicPerm = function () {\r\n    setTimeout(() => {\r\n      if (!userGaveMicPerm)\r\n        msg.setMsg(`You haven't given us permission to access the microphone.\r\n                        Don't worry this can be fixed :)`)\r\n    }, 200) //needed in order not to bug the system out if the mic is already blocked\r\n\r\n    setTimeout(() => {\r\n      if (!userGaveMicPerm)\r\n        msg.setMsg(`Refresh the page or click on the microphone icon in the address bar.\r\n                          You should then get a new prompt!`)\r\n    }, 6000)\r\n  }\r\n\r\n  /*\r\n  obtainedMicPerm: if the user gives us permission to access the microphone, confirm everything's ok\r\n  */\r\n  obtainedMicPerm = function () {\r\n    //if micCheck is not null, it means that we were checking for permission\r\n    //Clear micCheck\r\n\r\n    if (micCheck != null) {\r\n      clearInterval(micCheck)\r\n    }\r\n    userGaveMicPerm = true\r\n    msg = messages[currMessage]\r\n    helper.setWorking()\r\n  }\r\n\r\n  //--------------------METRONOME--------------------\r\n  /*\r\n  startMetronome(): starts a metronome for reference. Calls metroSound()\r\n  to make sound*/\r\n  var metroFlag = 0;\r\n  startMetronome = function () {\r\n    Tone.Transport.scheduleRepeat(time => {\r\n      metroSound()\r\n    }, \"4n\");\r\n  }\r\n\r\n  /*\r\n  metroSound(): produces the correct metronome sound based on the beat\r\n  */\r\n  metroSound = function () {\r\n    met2.play();\r\n    //no point using different sounds, we just need to give the user a reference\r\n  }\r\n\r\n}//end of sketch\r\n//--------------------END OF P5 SKETCH--------------------\r\n\r\nmyp5 = new p5(p5_instance)\r\n\r\ndocument.onblur = function () {\r\n  //pause audio and do not update circles\r\n  Tone.Transport.pause();\r\n  pageFoc = false;\r\n  //pause the game\r\n}\r\ndocument.onfocus = function () {\r\n  //resume audio and update circles\r\n  Tone.Transport.start();\r\n  pageFoc = true;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sketch.js b/sketch.js
--- a/sketch.js	(revision 6d92c7d3e99b3e2b2ecab79c51cecfd54402aaaf)
+++ b/sketch.js	(date 1674686567472)
@@ -524,7 +524,7 @@
   //var frameCounter = 0; //not used now, might be used to count frames IN GAME
 
   /*
-  draw(): p5js function that gets automatically called once per frame
+  (): p5js function that gets automatically called once per frame
   (by default 60 frames per second) 
   */
   p5c.draw = function () {
@@ -572,7 +572,7 @@
   */
   drawInterface = function () {
     //draw audio controls
-    drawAudioControls()
+    7()
 
     //draw a basic rectangle that will contain the waveform of the recorded/uploaded audio
     p5c.push()
